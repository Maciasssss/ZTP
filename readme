# .NET Garbage Collector Performance Testing Suite

A comprehensive testing framework for evaluating the impact of different .NET Garbage Collector (GC) configurations on memory-intensive operations like large matrix multiplication and image processing.

## Overview

This project provides tools to analyze how different .NET GC configurations affect application performance, memory usage patterns, and garbage collection behavior. The suite uses large matrix operations and bitmap processing to create measurable memory pressure that demonstrates the real-world impact of various GC settings.

## Components

1. **C# Test Application**: Performs memory-intensive operations
   - 15000Ã—15000 matrix multiplication (~1.8GB memory footprint)
   - Bitmap image processing with unmanaged memory

2. **PowerShell Testing Script**: Automates testing with different GC configurations
   - Sets environment variables to configure GC behavior
   - Launches the application with specific settings
   - Guides the testing workflow

3. **dotMemory Integration**: For visual memory profiling and analysis

## Prerequisites

- .NET SDK (6.0 or later)
- PowerShell 5.1 or later
- JetBrains dotMemory
- 8GB RAM minimum (16GB recommended for optimal performance)

## Getting Started

1. Clone this repository
2. Build the C# application:
   ```
   dotnet build -c Release
   ```
3. Start JetBrains dotMemory
4. Run the PowerShell script:
   ```powershell
   .\optimized-gc-testing.ps1
   ```
5. Follow the on-screen instructions to run the tests and capture memory snapshots

## GC Configurations Tested

| Test Name | Description | Environment Variables |
|-----------|-------------|----------------------|
| Baseline | Default settings for comparison | None |
| Server GC | Multiple GC heaps (parallel collection) | DOTNET_GCServer=1 |
| Workstation GC | Single GC heap | DOTNET_GCServer=0 |
| Low Memory Limit | Forces more frequent collections | DOTNET_GCHeapHardLimitPercent=25 |
| Low LOH Threshold | More objects on Large Object Heap | DOTNET_GCLOHThreshold=32768 |
| High LOH Threshold | Fewer objects on Large Object Heap | DOTNET_GCLOHThreshold=512000 |
| Aggressive Memory Conservation | Most aggressive memory conservation | DOTNET_GCConserveMemory=9 |
| Memory Conservation + LOH Compaction | Reduces fragmentation | DOTNET_GCConserveMemory=7, DOTNET_GCLargeObjectHeapCompactionMode=CompactOnce |
| Non-Concurrent GC | Disables background collections | DOTNET_GCConcurrent=0 |
| Server + Background GC | Parallel with background collections | DOTNET_GCServer=1, DOTNET_GCConcurrent=1 |
| Server GC + No CPU Groups | Explicit heap count | DOTNET_GCServer=1, DOTNET_GCCpuGroup=0, DOTNET_GCHeapCount=8 |

## How to Interpret Results

When analyzing dotMemory snapshots, look for:

1. **Memory Usage Patterns**
   - How quickly memory grows and is released
   - Peak memory consumption
   - Retained memory after operations

2. **GC Collection Metrics**
   - Collection frequency across generations
   - Duration of collections
   - Managed heap fragmentation

3. **Performance Impact**
   - Matrix multiplication execution time
   - Bitmap processing time
   - Correlation between GC pauses and operation times

## Expected Findings

Different GC configurations show distinctive behavior:

- **Server GC** typically performs better on multi-core systems but uses more memory
- **Workstation GC** has more frequent but shorter pauses, suitable for UI applications
- **Low Memory Limit** causes more aggressive collections but reduces overall memory footprint
- **LOH Threshold** changes affect fragmentation patterns and collection frequency/duration
- **Memory Conservation** settings make tradeoffs between CPU time and memory usage
- **Concurrent vs. Non-Concurrent** GC shows different pause patterns

## Customization

You can customize the test suite by:

- Adjusting matrix dimensions in `Program.cs` (modify LARGE_ROWS and LARGE_COLS)
- Adding more GC configurations to the PowerShell script
- Modifying the bitmap processing algorithm for different memory patterns

## Troubleshooting

- If your system has limited memory, reduce the matrix size constants to avoid excessive paging
- For more detailed collection data, add `GC.WaitForPendingFinalizers()` calls after explicit collections
- If dotMemory doesn't connect properly, try running as administrator

## References

- [.NET GC Configuration Documentation](https://learn.microsoft.com/en-us/dotnet/core/runtime-config/garbage-collector)
- [Understanding GC pauses in .NET Core](https://devblogs.microsoft.com/dotnet/gc-perf-series-understanding-gc-pauses/)
- [Large Object Heap Improvements](https://devblogs.microsoft.com/dotnet/large-object-heap-improvements-in-net-core-2-0/)
- [JetBrains dotMemory Documentation](https://www.jetbrains.com/help/dotmemory/Introduction.html)

## License

MIT License

## Acknowledgments

- Microsoft .NET team for the configurable GC implementation
- JetBrains for the dotMemory profilers